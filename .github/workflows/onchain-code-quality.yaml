# GitOps On-chain Code Quality Workflow - Callable from remote repositories
# Builds and runs code quality jobs for on-chain projects.
# This workflow is designed to be called from other repositories via 'workflow_call' event.

name: On-chain Code Quality
on:
  # Triggered from app repo's workflows
  workflow_call:
    inputs:
      gh-app-id:
        description: GitHub App ID for generating tokens
        type: string
        required: false
        default: ""
      project-repositories:
        description: Comma-separated list of project repositories to run the workflow on
        type: string
        required: false
        default: ""
      slither-target:
        description: Target directory or file for slither analysis
        type: string
        required: false
        default: "."
    outputs:
      status:
        description: The status of the deployment job, either 'success', 'failure', or 'skipped'
        value: ${{ jobs.check.result }}
    secrets:
      # Secrets are passed from the calling repository
      ALCHEMY_KEY: # optional, only if needed for tests requiring mainnet fork
        required: false
        description: Alchemy API URI for Ethereum mainnet (for tests requiring mainnet fork)
      POLYGON_ALCHEMY_KEY: # optional, only if needed for tests requiring polygon fork
        required: false
        description: Alchemy API URI for Polygon mainnet (for tests requiring polygon fork)

jobs:
  check:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Generate GitHub App token
        id: get-token
        if: inputs.gh-app-id != ''
        uses: actions/create-github-app-token@v2
        with: # The app-id needs to be set and private-key should be configured in the calling repository's secrets to access private repos.
          app-id: ${{ inputs.gh-app-id }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          repositories: ${{ inputs.project-repositories }}

      - name: Checkout local repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.get-token.outputs.token || github.token}}
          submodules: recursive

      - name: Checkout infrastructure-tooling repository
        uses: actions/checkout@v4
        with:
          repository: Forte-Service-Company-Ltd/infrastructure-tooling
          ref: v0.0.3
          path: infrastructure-tooling

      - name: Install Foundry
        id: install-foundry
        uses: Forte-Service-Company-Ltd/infrastructure-tooling/.github/actions/install-foundry@v0.0.7

      - name: Install Python Dependencies
        id: install-python-dependencies
        uses: Forte-Service-Company-Ltd/infrastructure-tooling/.github/actions/install-python-dependencies@v0.0.7

      - name: Build
        id: build
        uses: Forte-Service-Company-Ltd/infrastructure-tooling/.github/actions/onchain-build@v0.0.7

      - name: Slither Analysis
        id: slither-analysis
        uses: Forte-Service-Company-Ltd/infrastructure-tooling/.github/actions/slither-analysis@v0.0.7
        with:
          target: ${{ inputs.slither-target }}

      - name: Check for medusa.conf
        id: check-medusa-conf
        run: |
          if [ -f "medusa.json" ]; then
            echo "medusa-conf-exists=true" >> $GITHUB_OUTPUT
          else
            echo "medusa-conf-exists=false" >> $GITHUB_OUTPUT
          fi
      - name: Medusa Fuzz
        id: medusa-fuzz
        if: steps.check-medusa-conf.outputs.medusa-conf-exists == 'true'
        uses: Forte-Service-Company-Ltd/infrastructure-tooling/.github/actions/medusa-fuzz@v0.0.7

  notify:
    name: Notify Slack on Deployment Failure
    needs: [check]
    if: always() && (needs.check.result != 'success')
    uses: Forte-Service-Company-Ltd/infrastructure-tooling/.github/workflows/slack-notification.yaml@v0.0.14
    with:
      env: "onchain"
      status: ${{ needs.check.result }}
      title: "On-Chain Code Quality Checks of *${{ github.repository }}* failed."
      notify_when: "failure,skipped"
    secrets: inherit
